#!/usr/bin/python
# Copyright lowRISC contributors.
# Licensed under the Apache License, Version 2.0, see LICENSE for details.
# SPDX-License-Identifier: Apache-2.0

import os
# this is only for WDC environments
LOCAL_PROJ = os.getenv('LOCAL_PROJ')



# open file

read_file  = open (LOCAL_PROJ + "/../../opentitan/golden/hw/ip/aes/dv/test_vectors/nist_vectors.txt", "r")
write_file = open(LOCAL_PROJ + "/../../opentitan/golden/hw/ip/aes/dv/test_vectors/nist_vectors_pkg.sv", "w")

# add opensource header
write_file.write("""// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0\n\n""")


# scan through document
read_lines = 10;
# get header
write_file.write("//##############################################")
write_file.write("\n//# https://csrc.nist.gov/CSRC/media/Projects/Cryptographic")
write_file.write("\n//#-Standards-and-Guidelines/documents/examples/AES_ModesA_All.pdf")

write_file.write("\n//###############################################")
write_file.write("\n//#             AES TEST VECTORS                #")
write_file.write("\n//#  Modes: ECB, CTR, OFB, CFB  CBC             #")
write_file.write("\n//#  Key Lengths: 128bit, 192bit, 256bit        #")
write_file.write("\n//#                                             #")
write_file.write("\n//#  This File was autogenerated by an external #")
write_file.write("\n//#  script converting the PDF to systemverilog #")
write_file.write("\n//###############################################")

write_file.write("\npackage nist_vectors_pkg;")
write_file.write("\n\n  import uvm_pkg::*;")
write_file.write("\n  import aes_pkg::*;")


## create struct
write_file.write("\n\n  typedef struct {\
\n    aes_mode_e   mode;\
\n    key_len_e    key_len;\
\n    aes_op_e     operation;\
\n    bit [127:0]  iv;\
\n    bit [255:0]  key;\
\n    bit [3:0] [31:0]  plain_text[4];\
\n    bit [3:0] [31:0]  cipher_text[4];\
\n  } nist_vector_t;")
write_file.write("\n\n");


write_file.write("\n\n  function automatic string vector2string(nist_vector_t vector);\
\n    string              str;\
\n    str = $sformatf(\"\\n ----| NIST Vector | ----\");\
\n    str = $sformatf(\"%s \\n Mode: %s\", str, vector.mode.name);\
\n    str = $sformatf(\"%s \\n Key Len: %s\", str, vector.key_len.name);\
\n    str = $sformatf(\"%s \\n Key: %0h\", str, vector.key);\
\n    str = $sformatf(\"%s \\n Iv: %0h\", str, vector.iv);\
\n    str = $sformatf(\"%s \\n plaintext: %0h\", str, vector.plain_text[0]);\
\n    str = $sformatf(\"%s \\n plaintext: %0h\", str, vector.plain_text[1]);\
\n    str = $sformatf(\"%s \\n plaintext: %0h\", str, vector.plain_text[2]);\
\n    str = $sformatf(\"%s \\n plaintext: %0h\", str, vector.plain_text[3]);\
\n    str = $sformatf(\"%s \\n ciphertext: %0h\", str, vector.cipher_text[0]);\
\n    str = $sformatf(\"%s \\n ciphertext: %0h\", str, vector.cipher_text[1]);\
\n    str = $sformatf(\"%s \\n ciphertext: %0h\", str, vector.cipher_text[2]);\
\n    str = $sformatf(\"%s \\n ciphertext: %0h\", str, vector.cipher_text[3]);\
\n    return str;\
\n  endfunction // vector2string")


write_file.write("\n\n\n  class aes_nist_vectors extends uvm_object;")

write_file.write("\n    `uvm_object_utils(aes_nist_vectors)")

write_file.write("\n    nist_vector_t vector_q[];")
write_file.write("\n    int           num;")

write_file.write("\n\n\n    function new(string name = \"aes_nist_vectors\");\
\n      super.new();\
\n      num = get_num_vectors();\
\n      vector_q = new[num];\
\n      get_vectors(vector_q);\
\n    endfunction // new")


write_file.write("\n\n\n    function void get_vectors(ref nist_vector_t nist_vectors[]);")

mode    = "ECB"
key_len = "128"
Seg_len = "128"
Ivec    = "0"
my_str  = ""
c_i     = 0

while True:
    ##find mode
    search_for_mode = True
    while search_for_mode:
        line = read_file.readline()
        if not line:
            break
        words = line.split()

        #look for mode and key len
        if (len(words) > 1) and  (words[1] == "Counter" and words[2] == "is"):
            Ivec = read_file.readline().strip()
            Ivec = Ivec.replace(" ", "")
        else:
            for w in words:
                if w.strip() == "(Encryption)":
                    mode_key = words[0].split("-")
                    mode     = mode_key[0]
                    key_len  = mode_key[1].strip("AES")
                    my_str = my_str + "\n\n\n      // NIST VECTOR[" + str(c_i) + "] //"
                    my_str = my_str + "\n" + "      nist_vectors[" + str(c_i) \
                                           + "].mode    = AES_" + mode_key[0] + ";\n"
                    my_str = my_str + "      nist_vectors[" + str(c_i) \
                                           + "].key_len = AES_" + mode_key[1].strip("AES") + ";\n"
                    search_for_mode = False
                elif w.strip() == "IV":
                    Ivec = read_file.readline().strip()
                    Ivec = Ivec.replace(" ", "")


    # find KEY
    search_for_key = True
    Seg_len = "128"

    while search_for_key:
        line = read_file.readline()
        if not line:
            break
        words = line.split()

        #look for mode and key len
        for k in words:
            if k.strip() == "Key":
                if key_len != "128":
                    key = read_file.readline().strip() + " " + read_file.readline().strip()
                    key = key.replace(" ", "")
                    if key_len != "256":
                        key = key + "0000000000000000"
                    my_str = my_str + ("      nist_vectors[" + str(c_i) + "].key  = "
                                    + "256" + "'h" + key  + ";\n")
                else:
                    key = read_file.readline().strip() +  "0000000000000000" +  "0000000000000000"
                    key = key.replace(" ", "")
                    my_str = my_str + ("      nist_vectors[" + str(c_i) + "].key  = "
                                    + "256" + "'h" + key + ";\n")
                search_for_key = False
                # output IV (assume there is an IV if not ECB)
                if mode != "ECB":
                    my_str = my_str + ("      nist_vectors[" + str(c_i) + "].iv      = 128'h"
                                    + Ivec + ";\n")
                else:
                    my_str = my_str + ("      nist_vectors[" + str(c_i) + "].iv      = 128'h"
                                    + "0000000000000000" +  "0000000000000000"+ ";\n")
            elif k.strip() == "Segment":
                Seg_len = words[3]


    # plaintext
    search_for_plaintxt = True
    read_cnt = 0
    while search_for_plaintxt:
        line = read_file.readline()
        if not line:
            break
        words = line.split()
        for p in words:
            if p.strip() == "Plaintext":
                if int(Seg_len) > 8:
                    my_str = my_str + "      nist_vectors[" + str(c_i) + "].plain_text  = '{ "
                    while read_cnt < 4:
                        line = read_file.readline().strip()
                        if (line[0] != " ") and (line[0] !=  "=") and (line[0] != "-"):
                            line = line.replace(" ", "")
                            my_str = my_str + "128'h" + line
                            if read_cnt < 3:
                                my_str = my_str + ",\n                                       "
                            else:
                                my_str = my_str + "\n                                      "
                            read_cnt += 1

                    my_str = my_str + "};\n"
                search_for_plaintxt = False

    search_for_cipher = True
    read_cnt = 0
    while search_for_cipher:
        line = read_file.readline()
        if not line:
            break
        words = line.split()
        #look for Ciphertext is
        if (len(words) > 1) and  (words[0] == "Ciphertext") and (words[1] == "is"):
            if int(Seg_len) > 8:
                my_str = my_str + "      nist_vectors[" + str(c_i) + "].cipher_text = '{ "
                while read_cnt < 4:
                    line = read_file.readline().strip()
                    if (len(line) > 0) and ((line[0] != " ")
                                       and (line[0] !=  "=")
                                       and (line[0] != "-")):
                        line = line.replace(" ", "")
                        my_str = my_str +  "128'h" + line
                        if read_cnt < 3:
                            my_str = my_str + ",\n                                       "
                        else:
                            my_str = my_str + "\n                                      "
                        read_cnt += 1

                my_str = my_str + "};\n"

            search_for_cipher = False
            if int(Seg_len) == 128:
                write_file.write(my_str)
                c_i += 1


    my_str = ""
    eof = read_file.readline()
    if not eof:
        break

write_file.write("\n    endfunction")

write_file.write("\n\n    function int get_num_vectors();\n      return "
                 + str(c_i) + ";\n    endfunction")

write_file.write("\n\n  endclass")
write_file.write("\nendpackage")

read_file.close()
write_file.close()
